$date
	Mon Oct 27 22:11:53 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module mac_tb $end
$var wire 16 ! out [15:0] $end
$var reg 16 " a [15:0] $end
$var reg 16 # b [15:0] $end
$var reg 16 $ c [15:0] $end
$var reg 1 % clk $end
$var reg 16 & expected_out [15:0] $end
$var integer 32 ' i [31:0] $end
$var integer 32 ( w_dec0 [31:0] $end
$var integer 32 ) w_dec1 [31:0] $end
$var integer 32 * w_dec2 [31:0] $end
$var integer 32 + w_dec3 [31:0] $end
$var integer 32 , w_file [31:0] $end
$var integer 32 - w_scan_file [31:0] $end
$var integer 32 . x_dec0 [31:0] $end
$var integer 32 / x_dec1 [31:0] $end
$var integer 32 0 x_dec2 [31:0] $end
$var integer 32 1 x_dec3 [31:0] $end
$var integer 32 2 x_file [31:0] $end
$var integer 32 3 x_scan_file [31:0] $end
$scope function mac_predicted $end
$var reg 16 4 a [15:0] $end
$var reg 16 5 b [15:0] $end
$var reg 16 6 c [15:0] $end
$var reg 16 7 mac_predicted [15:0] $end
$upscope $end
$scope function w_bin $end
$var reg 4 8 w_bin [3:0] $end
$var integer 32 9 weight [31:0] $end
$upscope $end
$scope function x_bin $end
$var reg 4 : x_bin [3:0] $end
$var integer 32 ; activate [31:0] $end
$upscope $end
$scope module mac_wrapper_instance $end
$var wire 16 < a [15:0] $end
$var wire 16 = b [15:0] $end
$var wire 16 > c [15:0] $end
$var wire 1 % clk $end
$var wire 16 ? out [15:0] $end
$var reg 16 @ a_q [15:0] $end
$var reg 16 A b_q [15:0] $end
$var reg 16 B c_q [15:0] $end
$scope module mac_instance $end
$var wire 16 C a [15:0] $end
$var wire 16 D b [15:0] $end
$var wire 16 E c [15:0] $end
$var wire 20 F ua [19:0] $end
$var wire 16 G out [15:0] $end
$var wire 64 H mul [63:0] $end
$var wire 16 I adder23 [15:0] $end
$var wire 16 J adder01 [15:0] $end
$scope begin genblk1[0] $end
$upscope $end
$scope begin genblk1[1] $end
$upscope $end
$scope begin genblk1[2] $end
$upscope $end
$scope begin genblk1[3] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx J
bx I
bx H
bx G
b0xxxx0xxxx0xxxx0xxxx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
b10000000000000000000000000000100 2
bx 1
bx 0
bx /
bx .
bx -
b10000000000000000000000000000011 ,
bx +
bx *
bx )
bx (
bx '
b0 &
0%
bx $
bx #
bx "
bx !
$end
#2
1%
#3
b0 '
0%
#4
1%
#5
b1 '
b1111111111010000 &
b1111111111010000 7
b110011100010011 4
b1100101111100 5
b0 6
b0 $
b0 >
b1100101111100 #
b1100101111100 =
b1100 8
b0 9
b110011100010011 "
b110011100010011 <
b11 :
b11 ;
b100 3
b11 1
b1 0
b111 /
b110 .
b100 -
b11111111111111111111111111111100 +
b111 *
b11111111111111111111111111111001 )
b1 (
0%
#6
b1111111111010000 !
b1111111111010000 ?
b1111111111010000 G
b1111111111111011 J
b1111111111010101 I
b110111111111100111100000000000001111111111111110100 H
b110001110000100011 F
b0 B
b0 E
b110011100010011 @
b110011100010011 C
b1100101111100 A
b1100101111100 D
1%
#7
b10 '
b1111111110011110 &
b1111111110011110 7
b10001011110100 4
b1101111011000101 5
b1111111111010000 6
b1111111111010000 $
b1111111111010000 >
b1101111011000101 #
b1101111011000101 =
b101 8
b1 9
b10001011110100 "
b10001011110100 <
b100 :
b100 ;
b100 1
b1111 0
b10 /
b10 .
b101 +
b11111111111111111111111111111100 *
b11111111111111111111111111111110 )
b11111111111111111111111111111101 (
0%
#8
b1111111111011000 J
b1111111111110110 I
b10000100111100100 F
b1111111111111010111111111111110011111111110001000000000000010100 H
b1111111110011110 !
b1111111110011110 ?
b1111111110011110 G
b1111111111010000 B
b1111111111010000 E
b10001011110100 @
b10001011110100 C
b1101111011000101 A
b1101111011000101 D
1%
#9
b11 '
b1111111110000110 &
b1111111110000110 7
b110010000000010 4
b1010010000101110 5
b1111111110011110 6
b1111111110011110 $
b1111111110011110 >
b1010010000101110 #
b1010010000101110 =
b1110 8
b0 9
b110010000000010 "
b110010000000010 <
b10 :
b10 ;
b10 1
b0 0
b100 /
b110 .
b11111111111111111111111111111110 +
b10 *
b100 )
b11111111111111111111111111111010 (
0%
#10
b1111111111111100 J
b1111111111101100 I
b110001000000000010 F
b1111111111011100000000000001000000000000000000001111111111111100 H
b1111111110000110 !
b1111111110000110 ?
b1111111110000110 G
b1111111110011110 B
b1111111110011110 E
b110010000000010 @
b110010000000010 C
b1010010000101110 A
b1010010000101110 D
1%
#11
b100 '
b1111111101011001 &
b1111111101011001 7
b1101000101011 4
b110000111111 5
b1111111110000110 6
b1111111110000110 $
b1111111110000110 >
b110000111111 #
b110000111111 =
b1 9
b1111 8
b1101000101011 "
b1101000101011 <
b1011 :
b1011 ;
b1011 1
b10 0
b1010 /
b1 .
b11111111111111111111111111111111 +
b11 *
b11111111111111111111111111111100 )
b0 (
0%
#12
b1111111111111011 J
b1111111111011000 I
b1010100001001011 F
b111111111101100000000000000001101111111111110101 H
b1111111101011001 !
b1111111101011001 ?
b1111111101011001 G
b1111111110000110 B
b1111111110000110 E
b1101000101011 @
b1101000101011 C
b110000111111 A
b110000111111 D
1%
#13
b101 '
b1111111101111111 &
b1111111101111111 7
b10011001001010 4
b1100010110100100 5
b1111111101011001 6
b1111111101011001 $
b1111111101011001 >
b1100010110100100 #
b1100010110100100 =
b100 8
b0 9
b10011001001010 "
b10011001001010 <
b1010 :
b1010 ;
b1010 1
b100 0
b110 /
b10 .
b100 +
b11111111111111111111111111111010 *
b101 )
b11111111111111111111111111111100 (
0%
#14
b10000 J
b10110 I
b10001100010001010 F
b1111111111111000000000000001111011111111111010000000000000101000 H
b1111111101111111 !
b1111111101111111 ?
b1111111101111111 G
b1111111101011001 B
b1111111101011001 E
b10011001001010 @
b10011001001010 C
b1100010110100100 A
b1100010110100100 D
1%
#15
0%
#25
